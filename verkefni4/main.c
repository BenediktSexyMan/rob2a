#pragma config(Sensor, in2,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl4,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl12, breakSwitch,    sensorTouch)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define BIG_D 32.4
#define LITTLE_D 10.4
#define LITTLE_D_C 32.67
#define CORRECTION_CONSTANT 1.02

int tempArr[2];
unsigned int minDist = 35;
bool turned = true;

void resetEncoders()
{
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder]  = 0;
}

void stopMotors()
{
	motor[rightMotor] = 0;
	motor[leftMotor]  = 0;
}

void reset(unsigned int sleepMilli = 0)
{
	stopMotors();
	resetEncoders();
	Sleep(sleepMilli);
}

void calibrate(int speed=80)
{
	int direction = speed/abs(speed);
	float Ntime1 = 0, Ntime2 = 0, Ntime3 = 0;
	int Stateout = 0;
	resetEncoders();
	for (int i=1; i<2000; i++)
	{
		motor[rightMotor] = speed;
		motor[leftMotor] = speed;
	}
	resetEncoders();
	Ntime3 = nPgmTime;
  while(Stateout<2)
  {
		Stateout = 0;
  	if (direction*-SensorValue[rightEncoder]<direction*speed*10)
  	{
  		motor[rightMotor] = speed;
  		Ntime1=((float)nPgmTime);
  	}
  	else if (direction*-SensorValue[rightEncoder]==direction*speed*10)
  	{
  		motor[rightMotor] = speed;
  	}
  	else
  	{
  		motor[rightMotor] = 0;
  		Stateout = Stateout + 1;
  	}
  	if (direction*-SensorValue[leftEncoder]<direction*speed*10)
  	{
  		motor[leftMotor] = speed;
  		Ntime2=((float)nPgmTime);
  	}
  	else if (direction*-SensorValue[leftEncoder]==direction*speed*10)
  	{
  		motor[leftMotor] = speed;
  	}
  	else
  	{
  		motor[leftMotor] = 0;
  		Stateout = Stateout + 1;
  	}
  }
  Ntime1 = (Ntime1 - Ntime3);
	Ntime2 = (Ntime2 - Ntime3);
	if (Ntime1 >Ntime2)
	{
		Ntime3=Ntime2;
	}
	else
	{
		Ntime3=Ntime1;
	}
	Ntime1 = Ntime1/Ntime3;
	Ntime2 = Ntime2/Ntime3;
	resetEncoders();
	tempArr[0] = 2*(-speed*(2-abs(direction*speed/126))*(Ntime1-Ntime2));
	tempArr[1] = 2*(-speed*(2-abs(direction*speed/126))*(Ntime2-Ntime1));
}

string moveKey = "";
bool drive(unsigned int distance, const string key, bool reversed = false, int speed=80, unsigned int waitTime = 0)
{
	int amount = ((float)distance/LITTLE_D_C)*300.0;
	if(moveKey != key)
	{
		reset(waitTime);
		moveKey = key;
	}
	if(!reversed)
	{
		if(SensorValue[leftEncoder] > -amount && SensorValue[rightEncoder] > -amount)
		{
			motor[rightMotor] = (speed-tempArr[0]);
			motor[leftMotor]  = (speed-tempArr[1]);
			return false;
		}
	}
	else
	{
		if(SensorValue[leftEncoder] < amount && SensorValue[rightEncoder] < amount)
		{
			motor[rightMotor] = -speed;//(speed-tempArr[0]);
			motor[leftMotor]  = -speed;//(speed-tempArr[1]);
			return false;
		}
	}
	return true;
}

void drive(bool reverse=false, unsigned int speed=80)
{
	if(!reverse)
	{
		motor[rightMotor] = (speed-tempArr[0]);
		motor[leftMotor]  = (speed-tempArr[1]);
	}
	else
	{
		motor[rightMotor] = -speed;
		motor[leftMotor]  = -speed;
	}
}

void turnSimple(int degs)
{
	reset();
	int speed = 80;
	int amount = ((BIG_D/LITTLE_D)*(float)abs(degs))*CORRECTION_CONSTANT;
	if(degs < 0)
	{
		while(SensorValue[leftEncoder] > -amount && SensorValue[rightEncoder] < amount)
		{
			motor[rightMotor] = -speed;
			motor[leftMotor]  = speed;
		}
	}
	else if(degs > 0)
	{
		while(SensorValue[leftEncoder] < amount && SensorValue[rightEncoder] > -amount)
		{
			writeDebugStreamLine("Turning loop");
			motor[rightMotor] = speed;
			motor[leftMotor]  = -speed;
		}
	}
}

task stopRobot
{
	while(true)
	{
		if(SensorValue[breakSwitch] || vexRT[Btn8U])
			StopAllTasks();
	}
}

task main
{
	StartTask(stopRobot);
	calibrate();
	for(unsigned int i = 0; true; i++)
	{
		if(!(SensorValue(lightSensor) > 230))
		{
			if(SensorValue(sonarSensor) > minDist && turned)
			{
				moveKey="";
				drive();
			}
			else
			{
				turned = false;
				if(drive(50, "backup", true))
				{
					turnSimple(45);
					turned = true;
				}
			}
		}
		else
		{
			stopMotors();
		}
	}
}
